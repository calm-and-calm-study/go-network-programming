
### net.Conn 인터페이스 

- 네트워크 코드의 대부분은 net.Conn 인터페이스에서 프로그래밍을 할 수 있음

- io.Reader, io.Writer 인터페이스를 구현

- SetReadDeadline, SetWriteDeadline 메서드는 매개변수로 입력받은 시간을 데드라인으로 설정하여 
  각각 읽기및 쓰기 동시에 대해 매개변수로 입력받은 시간을 데드라인으로 설정합니다.

- 네트워크 연결로부터 데이터를 읽고 쓰는 것은 파일 객체에 데이터를 읽고 쓰는 것과 같음
  이유는 net.Conn 인터페이스가 파일 객체의 io 를 구현한 io.ReadWriteCloser 인터페이스를 구현했기 때문

- bufio.Scanner 메서드를 이용하여 특정 구분자를 만날 때까지 데이터를 읽는 방법을 알아봄

- 다변하는 페이로드 크기로부터 동적으로 버퍼를 할당하는 기본 프로토콜을 정의할 수 있도록 해주는 인코딩 메서드인 TLV 

- 네트워크 연결로부터 데이터를 읽고 쓸 때 발생하는 에러를 처리하는 방법을 알아보는 시간

<br />

### reflect.DeepEqual

- 두 개의 값을 깊은 비교(Deep Comparision)

- 두 값을 재귀저긍로 비교, 데이터의 순서까지 비교, 값이 모두 동일해야 True 반환

```go
package main

import (
	"fmt"
	"reflect"
)

func main() {
	m1 := map[string]int{"a": 1, "b": 2}
	m2 := map[string]int{"b": 2, "a": 1} // 키 순서 다름

	fmt.Println(reflect.DeepEqual(m1, m2)) // true (맵은 키 순서 무관)
}
```

- 신기한 부분은 map 의 키 순서가 달라도 true 반환함 (맵은 순서가 달라도 상관 없어서 같다고 판단함)


<br />

### TLV (type-Length-Value)

- TLV 인코딩 체계는 가변 길이의 데이터를 처리하기 위한 방법

- 데이터 유형을 나타내는 정해진 길이의 바이트, 값의 크기를 나타내는 정해진 길이의 바이트, 값 자체를 나타내는 가변 길이의 바이트로 표현됨

<br />

## 데이터를 읽고 쓰는 도중 에러 처리

- 데이터를 네트워크 연결에 쓰는 것은 항상 보장될 수 없음, 이유는 네트워크 연결이 항상 원활하다는 것을 보장하지 못하기 때문

- ```nErr.Temporary()``` 는 일시적인 네트워크 오류에 따른 에러 타입임

- 일시적인 네트워크 연결 오류로 데이터 전송이 실패하면 안되기 때문에 golang for 루프로 데이터 쓰기가 이루어짐

- 또한 안정적인 네트워크 애플리케이션을 만들기 위해 io.Copy, io.MultiWriter, io.TeeReader 함수를 제공하고 있음

<br />

### io.Copy

- 이 함수는 io.Reader 에서 데이터를 읽어서 io.Writer 로 데이터를 쓸 수 있는 함수

- io.Reader 와 io.Writer 인터페이스를 둘다 포함하고 있음으로 두 노드 중간에서 데이터를 전송하는 proxy 를 생성하는데 유용함

- 이 함수는 출발 노드에서 목적지 노드로 데이터를 복제하는 역할을 함

<br />

### ICMP 가 필터링된 환경에서 호스트로 핑 전송

- ICMP (인터넷 제어 메시지 프로토콜) 로컬 네트워크의 상태를 확인할 수 있는 프로토콜

- 대부분의 인터넷 호스트들은 ICMP 에코 응답 요청을 필터링하거나 차단합니다.

<br />

### 연결 종료 시 보류중인 데이터 처리

- 데이터를 net.Conn 객체에 썼지만 데이터가 아직 전송되지 못했거나 수신자가 아직 확인 패킷을 보내지 않은 상태에서 네트워크 연결이 끊긴 경우, 기본적으로 운영체제는 백그라운드에서 데이터 전송을 마무리합니다.

```go
err := tcpConn.SetLinger(-1)
```

- linger 를 사용하지 않으면 네트워크 연결 종료 시에 서버는 클라이언트가 마지막으로 보낸 데이터와 함께 FIN 패킷을 같이 받게 됩니다.

- 그러나 클라이언트는 네트워크 연결이 끊겼기 때문에 서버가 FIN 패킷 이전에 보낸 데이터를 정상적으로 수신하였는지 알 수 없습니다.

- 또한 데이터가 수신 버퍼에 머물다가 서버가 마지막에 보낸 데이터와 충돌해서 FIN 패킷도 같이 사라질 수 있습니다.

- 서버에서 충돌할 가능성이 있기 때문에 linger 를 사용하는 것은 권장하지 않습니다.

```go
err := tcpConn.SetLinger(0)
```

- linger 값을 0으로 설정하면 코드상에서 연결 객체의 Close 메서드 호출 시에 RST 패킷을 보내게 됩니다.

- RST 패킷을 받게 되면 즉시 연결을 중단하고 일반적인 종료 절차를 무시하게 됩니다.

<br />

```go
err := tcpConn.SetLinger(10)
```

- linger 의 값을 적용하면 최대 n초까지 기다리다가 승인되지 않은 모든 데이터를 버립니다.

<br />

### 일반적인 go TCP 네트워크 문제 해결

- 제로 윈도 에러 : 네트워크 연결에서 데이터를 충분히 빠르게 읽지 못한 경우 결국 송신자는 수신자의 수신 버퍼를 가득 채우게 될 것이고, 그 결과 제로윈도 상태가 됩니다.

- 애플리케이션이 버퍼로부터 데이터를 추가로 읽기 전까지 데이터를 더 이상 수신하지 못하는 상태가 될 것입니다.

<br />

### 소켓이 CLOSE_WAIT 상태에서 멈춘 경우 

- TCP 네트워크 연결의 서버 사이드는 클라이언트로부터 FIN 패킷의 확인 패킷을 받은 후에 CLOSE_WAIT 상태가 됩니다.

- TCP 소켓이 계속해서 CLOSE_WAIT 상태에 머물러 있다면 애플리케이션의 Close 메서드 호출을 실패했을 수도 있습니다.

- 이 상태에서 CLOSE_WAIT 상태에서 클라이언트로 FIN 패킷 외의 데이터를 보내게 된다면 클라이언트는 연결이 끊긴 것으로 간주하고 RST 패킷으로 응답하여 연결을 끊어버립니다.

- golang 에서는 고루틴이 생성된 직후 defer 로 연결객체의 Close 메서드를 호출해주는 것이 좋습니다.

